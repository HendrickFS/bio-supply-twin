"""
Bio Supply Digital Twin Service - Database Manager
=================================================

Purpose:
    Async database manager for accessing Django SQLite database from the
    digital twin service. Provides read-only access to biological samples
    and transport box data with optimal performance.

Key Features:
    - Async SQLite operations using aiosqlite
    - Read access to Django ORM-generated tables
    - Error handling and logging for database operations
    - Efficient data retrieval with proper SQL joins
    - Type-safe data structures and return values

Database Tables:
    - core_transportbox: Transport container records
    - core_sample: Biological sample records
    - core_telemetryreading: Time-series readings (optional FK to box or sample)
    - core_slaconfig: SLA threshold bands
    - core_alert: Alerts generated by analytics
    - Relationships: sample.box_id -> transportbox.id

Methods:
    - get_sample(sample_id): Retrieve specific sample with box info
    - get_box(box_id): Retrieve specific transport box
    - get_all_samples(): Retrieve all samples with basic info
    - get_all_boxes(): Retrieve all transport boxes with basic info
    - get_sample_count(): Get total count of samples
    - get_box_count(): Get total count of transport boxes
    - get_active_alert_count(): Get total count of active alerts
    - get_telemetry(box_id?, sample_id?, since?): List telemetry points
    - create_sla/get_sla/list_sla: Manage SLA configs
    - create_alert/list_alerts/active_alerts: Manage alerts

Database Path: ../db.sqlite3 (Django SQLite database)
Dependencies: aiosqlite for async database operations

"""

import aiosqlite

class DatabaseManager:
    def __init__(self):
        self.db_path = '../db.sqlite3'
    
    async def get_all_samples(self):
        """Fetch all samples from the database."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT * FROM core_sample JOIN core_transportbox ON core_sample.box_id = core_transportbox.id"
                async with db.execute(query) as cursor:
                    rows = await cursor.fetchall()
                    samples = []
                    for row in rows:
                        samples.append({
                            'sample_id': row[1],
                            'box_id': row[2],
                            'name': row[3],
                            'description': row[4],
                            'collected_at': row[5],
                            'status': row[6],
                            'temperature': row[7],
                            'humidity': row[8],
                            'last_updated': row[9],
                        })
                    return samples
        except Exception as e:
            print(f"Error fetching samples: {e}")
            return []

    async def get_sample(self, sample_id):
        """Fetch a sample by its ID."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT * FROM core_sample JOIN core_transportbox ON core_sample.box_id = core_transportbox.id WHERE core_sample.sample_id = ?"
                async with db.execute(query, (sample_id,)) as cursor:
                    row = await cursor.fetchone()
                    if row:
                        return {
                            'sample_id': row[1],
                            'box_id': row[2],
                            'name': row[3],
                            'description': row[4],
                            'collected_at': row[5],
                            'status': row[6],
                            'temperature': row[7],
                            'humidity': row[8],
                            'last_updated': row[9],
                        }
                    return None
        except Exception as e:
            print(f"Error fetching sample {sample_id}: {e}")
            return None
        
    async def sample_count(self):
        """Get the total count of samples."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT COUNT(*) FROM core_sample"
                async with db.execute(query) as cursor:
                    row = await cursor.fetchone()
                    return row[0] if row else 0
        except Exception as e:
            print(f"Error counting samples: {e}")
            return 0
        
    async def get_all_boxes(self):
        """Fetch all transport boxes from the database."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT * FROM core_transportbox"
                async with db.execute(query) as cursor:
                    rows = await cursor.fetchall()
                    boxes = []
                    for row in rows:
                        boxes.append({
                            'box_id': row[1],
                            'geolocation': row[2],
                            'temperature': row[3],
                            'humidity': row[4],
                            'last_updated': row[5],
                            'status': row[6],
                        })
                    return boxes
        except Exception as e:
            print(f"Error fetching boxes: {e}")
            return []
        
    async def get_box(self, box_id):
        """Fetch a transport box by its ID."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT * FROM core_transportbox WHERE box_id = ?"
                async with db.execute(query, (box_id,)) as cursor:
                    row = await cursor.fetchone()
                    if row:
                        return {
                            'box_id': row[1],
                            'geolocation': row[2],
                            'temperature': row[3],
                            'humidity': row[4],
                            'last_updated': row[5],
                            'status': row[6],
                        }
                    return None
        except Exception as e:
            print(f"Error fetching box {box_id}: {e}")
            return None

    async def box_count(self):
        """Get the total count of transport boxes."""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT COUNT(*) FROM core_transportbox"
                async with db.execute(query) as cursor:
                    row = await cursor.fetchone()
                    return row[0] if row else 0
        except Exception as e:
            print(f"Error counting boxes: {e}")
            return 0

    async def active_alert_count(self):
        try:
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT COUNT(*) FROM core_alert WHERE is_active = 1"
                async with db.execute(query) as cursor:
                    row = await cursor.fetchone()
                    return row[0] if row else 0
        except Exception as e:
            print(f"Error counting active alerts: {e}")
            return 0

    async def list_telemetry(self, box_id: int = None, sample_id: int = None, since_iso: str = None):
        try:
            async with aiosqlite.connect(self.db_path) as db:
                base = "SELECT id, box_id, sample_id, timestamp, temperature, humidity, geolocation FROM core_telemetryreading"
                clauses = []
                params = []
                if box_id is not None:
                    clauses.append("box_id = ?")
                    params.append(box_id)
                if sample_id is not None:
                    clauses.append("sample_id = ?")
                    params.append(sample_id)
                if since_iso is not None:
                    clauses.append("timestamp >= ?")
                    params.append(since_iso)
                where = (" WHERE " + " AND ".join(clauses)) if clauses else ""
                order = " ORDER BY timestamp DESC LIMIT 1000"
                query = base + where + order
                async with db.execute(query, params) as cursor:
                    rows = await cursor.fetchall()
                    return [
                        {
                            'id': r[0], 'box': r[1], 'sample': r[2], 'timestamp': r[3],
                            'temperature': r[4], 'humidity': r[5], 'geolocation': r[6]
                        } for r in rows
                    ]
        except Exception as e:
            print(f"Error listing telemetry: {e}")
            return []

    async def create_sla(self, name: str, temp_min: float, temp_max: float, humidity_min: float, humidity_max: float):
        try:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    "INSERT INTO core_slaconfig (name, temp_min, temp_max, humidity_min, humidity_max, created_at, updated_at) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)",
                    (name, temp_min, temp_max, humidity_min, humidity_max),
                )
                await db.commit()
                return True
        except Exception as e:
            print(f"Error creating SLA: {e}")
            return False

    async def list_sla(self):
        try:
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT id, name, temp_min, temp_max, humidity_min, humidity_max, created_at, updated_at FROM core_slaconfig ORDER BY id DESC"
                async with db.execute(query) as cursor:
                    rows = await cursor.fetchall()
                    return [
                        {
                            'id': r[0], 'name': r[1], 'temp_min': r[2], 'temp_max': r[3],
                            'humidity_min': r[4], 'humidity_max': r[5], 'created_at': r[6], 'updated_at': r[7]
                        } for r in rows
                    ]
        except Exception as e:
            print(f"Error listing SLA: {e}")
            return []

    async def create_alert(self, payload: dict):
        try:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    "INSERT INTO core_alert (box_id, sample_id, type, severity, message, started_at, last_seen_at, resolved_at, acknowledged_at, is_active) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    (
                        payload.get('box'), payload.get('sample'), payload['type'], payload['severity'], payload.get('message', ''),
                        payload['started_at'], payload['last_seen_at'], payload.get('resolved_at'), payload.get('acknowledged_at'), 1 if payload.get('is_active', True) else 0
                    ),
                )
                await db.commit()
                return True
        except Exception as e:
            print(f"Error creating alert: {e}")
            return False

    async def list_alerts(self, active_only: bool = False):
        try:
            async with aiosqlite.connect(self.db_path) as db:
                base = "SELECT id, box_id, sample_id, type, severity, message, started_at, last_seen_at, resolved_at, acknowledged_at, is_active FROM core_alert"
                where = " WHERE is_active = 1" if active_only else ""
                order = " ORDER BY started_at DESC"
                query = base + where + order
                async with db.execute(query) as cursor:
                    rows = await cursor.fetchall()
                    return [
                        {
                            'id': r[0], 'box': r[1], 'sample': r[2], 'type': r[3], 'severity': r[4], 'message': r[5],
                            'started_at': r[6], 'last_seen_at': r[7], 'resolved_at': r[8], 'acknowledged_at': r[9], 'is_active': bool(r[10])
                        } for r in rows
                    ]
        except Exception as e:
            print(f"Error listing alerts: {e}")
            return []